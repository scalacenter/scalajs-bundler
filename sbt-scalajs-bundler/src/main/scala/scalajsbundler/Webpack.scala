package scalajsbundler

import sbt._
import scalajsbundler.util.{Commands, JS}
import java.io.InputStream

import play.api.libs.json._
import Stats._

import scala.util.{Failure, Success, Try}

object Webpack {
  // Represents webpack 5 modes
  sealed trait WebpackMode {
    def mode: String
  }
  case object DevelopmentMode extends WebpackMode {
    val mode = "development"
  }
  case object ProductionMode extends WebpackMode {
    val mode = "production"
  }
  object WebpackMode {
    def fromBooleanProductionMode(productionMode: Boolean): WebpackMode =
      if (productionMode) ProductionMode
      else DevelopmentMode
  }

  /**
    * Copies the custom webpack configuration file and the webpackResources to the target dir
    *
    * @param targetDir target directory
    * @param webpackResources Resources to copy
    * @param customConfigFile User supplied config file
    * @return The copied config file.
    */
  def copyCustomWebpackConfigFiles(targetDir: File, webpackResources: Seq[File])(customConfigFile: File): File = {
    def copyToWorkingDir(targetDir: File)(file: File): File = {
      val copy = targetDir / file.name
      IO.copyFile(file, copy)
      copy
    }

    webpackResources.foreach(copyToWorkingDir(targetDir))
    copyToWorkingDir(targetDir)(customConfigFile)
  }

  /**
    * Writes the webpack configuration file. The output file is designed to be minimal, and to be extended,
    * however, the `entry` and `output` keys must be preserved in order for the bundler to work as expected.
    *
    * @param emitSourceMaps Whether source maps is enabled at all
    * @param entry The input entrypoint file to process via webpack
    * @param webpackConfigFile webpack configuration file to write to
    * @param libraryBundleName If defined, generate a library bundle named `libraryBundleName`
    * @param log Logger
    */
  def writeConfigFile(
    emitSourceMaps: Boolean,
    entry: BundlerFile.WebpackInput,
    webpackConfigFile: BundlerFile.WebpackConfig,
    libraryBundleName: Option[String],
    mode: WebpackMode,
    devServerPort: Int,
    log: Logger
  ): Unit = {
    val webpackConfigContent = generateConfigFile(emitSourceMaps, entry, webpackConfigFile, libraryBundleName, mode,
      devServerPort)

    log.info("Writing scalajs.webpack.config.js")
    IO.write(webpackConfigFile.file, webpackConfigContent.show)
  }

  private def generateConfigFile(
    emitSourceMaps: Boolean,
    entry: BundlerFile.WebpackInput,
    webpackConfigFile: BundlerFile.WebpackConfig,
    libraryBundleName: Option[String],
    mode: WebpackMode,
    devServerPort: Int
  ): JS = {
    val webpackNpmPackage = NpmPackage.getForModule(webpackConfigFile.targetDir.toFile, "webpack")
    webpackNpmPackage.flatMap(_.major) match {
      case Some(5) =>
        // Build the output configuration, configured for library output
        // if a library bundle name is provided
        val output = libraryBundleName match {
          case Some(bundleName) =>
            JS.obj(
              "path" -> JS.str(webpackConfigFile.targetDir.toAbsolutePath.toString),
              "filename" -> JS.str(BundlerFile.Library.fileName("[name]")),
              "library" -> JS.str(bundleName),
              "libraryTarget" -> JS.str("var")
            )
          case None =>
            JS.obj(
              "path" -> JS.str(webpackConfigFile.targetDir.toAbsolutePath.toString),
              "filename" -> JS.str(BundlerFile.ApplicationBundle.fileName("[name]"))
            )
        }

        JS.ref("module").dot("exports").assign(JS.obj(Seq(
          "entry" -> JS.obj(
            entry.project -> JS.arr(JS.str(entry.file.absolutePath))
          ),
          "output" -> output,
          "mode" -> JS.str(mode.mode),
          "devServer" -> JS.obj("port" -> JS.int(devServerPort)),
        ) ++ (
          if (emitSourceMaps) {
            Seq(
              "devtool" -> JS.str("source-map"),
              "module" -> JS.obj(
                "rules" -> JS.arr(
                  JS.obj(
                    "test" -> JS.regex("\\.js$"),
                    "enforce" -> JS.str("pre"),
                    "use" -> JS.arr(JS.str("source-map-loader"))
                  )
                )
              )
            )
          } else Nil
          ): _*))

      case Some(x) =>
        sys.error(s"Unsupported webpack major version $x")

      case None =>
        sys.error("No webpack version defined")
    }
  }

  /**
    * Run webpack to bundle the application.
    *
    * @param emitSourceMaps Whether or not source maps are enabled
    * @param generatedWebpackConfigFile Webpack config file generated by scalajs-bundler
    * @param customWebpackConfigFile User supplied config file
    * @param webpackResources Additional resources to be copied to the working folder
    * @param entry Scala.js application to bundle
    * @param targetDir Target directory (and working directory for Nodejs)
    * @param extraArgs Extra arguments passed to webpack
    * @param mode Mode for webpack 5
    * @param devServerPort Port used by webpack-dev-server
    * @param log Logger
    * @return The generated bundles
    */
  def bundle(
     emitSourceMaps: Boolean,
     generatedWebpackConfigFile: BundlerFile.WebpackConfig,
     customWebpackConfigFile: Option[File],
     webpackResources: Seq[File],
     entry: BundlerFile.Application,
     targetDir: File,
     extraArgs: Seq[String],
     nodeArgs: Seq[String],
     mode: WebpackMode,
     devServerPort: Int,
     log: Logger
  ): BundlerFile.ApplicationBundle = {
    writeConfigFile(emitSourceMaps, entry, generatedWebpackConfigFile, None, mode, devServerPort, log)

    val configFile = customWebpackConfigFile
      .map(Webpack.copyCustomWebpackConfigFiles(targetDir, webpackResources))
      .getOrElse(generatedWebpackConfigFile.file)

    log.info("Bundling the application with its NPM dependencies")
    val args = extraArgs ++: Seq("--config", configFile.absolutePath)
    val stats = Webpack.run(nodeArgs: _*)(args: _*)(targetDir, log)
    stats.print(log)

    // Attempt to discover the actual name produced by webpack indexing by chunk name and discarding maps
    val bundle = generatedWebpackConfigFile.asApplicationBundle(stats)
    bundle
  }

  /**
    * Run webpack to bundle the application.
    *
    * @param emitSourceMaps Are source maps enabled?
    * @param generatedWebpackConfigFile Webpack config file generated by scalajs-bundler
    * @param customWebpackConfigFile User supplied config file
    * @param webpackResources Additional webpack resources to include in the working directory
    * @param entryPointFile The entrypoint file to bundle dependencies for
    * @param libraryModuleName The library module name to assign the webpack bundle to
    * @param extraArgs Extra arguments passed to webpack
    * @param mode Mode for webpack 5
    * @param log Logger
    * @return The generated bundle
    */
  def bundleLibraries(
    emitSourceMaps: Boolean,
    generatedWebpackConfigFile: BundlerFile.WebpackConfig,
    customWebpackConfigFile: Option[File],
    webpackResources: Seq[File],
    entryPointFile: BundlerFile.EntryPoint,
    libraryModuleName: String,
    extraArgs: Seq[String],
    nodeArgs: Seq[String],
    mode: WebpackMode,
    devServerPort: Int,
    log: Logger
  ): BundlerFile.Library = {
    writeConfigFile(
      emitSourceMaps,
      entryPointFile,
      generatedWebpackConfigFile,
      Some(libraryModuleName),
      mode,
      devServerPort,
      log
    )

    val configFile = customWebpackConfigFile
      .map(Webpack.copyCustomWebpackConfigFiles(generatedWebpackConfigFile.targetDir.toFile, webpackResources))
      .getOrElse(generatedWebpackConfigFile.file)

    val args = extraArgs ++: Seq("--config", configFile.absolutePath)
    val stats = Webpack.run(nodeArgs: _*)(args: _*)(generatedWebpackConfigFile.targetDir.toFile, log)
    stats.print(log)

    val library = generatedWebpackConfigFile.asLibrary(stats)
    library
  }

  private def jsonOutput(cmd: Seq[String], logger: Logger)(in: InputStream): Try[WebpackStats] = {
    Try(Json.parse(in))
      .fold(
        e => Failure(
          new RuntimeException(
            "Failure on parsing the output of webpack\n" +
            "You can try to manually execute the command\n" +
            s"${cmd.mkString(" ")}",
            e
          )
        ),
        parsed => {
          parsed.validate[WebpackStats] match {
            case JsError(e) =>
              Failure(
                new RuntimeException(
                  "Error parsing webpack stats output\n" +
                  s"${e.map { case (p, v) => s"$p: ${v.mkString(",")}"}.mkString("\n")}"
                )
              )
            case JsSuccess(p, _) =>
              if (p.warnings.nonEmpty || p.errors.nonEmpty) {
                logger.info("")
                // Filtering is a workaround for #111
                p.warnings.filterNot(_.message.contains("https://raw.githubusercontent.com")).foreach { warning =>
                  logger.warn(s"WARNING")
                  logger.warn(warning.format())
                  logger.warn("\n")
                }
                p.errors.foreach { error =>
                  logger.error(s"ERROR")
                  logger.error(error.format())
                  logger.error("\n")
                }
              }
              Success(p)
          }
        }
      )
  }

  /**
    * Runs the webpack command.
    *
    * @param nodeArgs node.js cli flags
    * @param args Arguments to pass to the webpack command
    * @param workingDir Working directory in which the Nodejs will be run (where there is the `node_modules` subdirectory)
    * @param log Logger
    */
  def run(nodeArgs: String*)(args: String*)(workingDir: File, log: Logger): WebpackStats = {
    val webpackBin = workingDir / "node_modules" / "webpack" / "bin" / "webpack"
    val params = nodeArgs ++ Seq(webpackBin.absolutePath, "--profile", "--json") ++ args
    val cmd = "node" +: params
    log.debug(s"Running command [${cmd.mkString(" ")}]")
    Commands.run(cmd, workingDir, log, jsonOutput(cmd, log))
      .fold(
        sys.error,
        _.map(_.get).getOrElse(throw new RuntimeException("Failure on returning webpack stats from command output"))
      )
  }

}
