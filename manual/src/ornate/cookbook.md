# Cookbook

![](toctree:local=true,mergeFirst=true)

## How to use a custom webpack configuration file? {#custom-config}

First, configure the `webpackConfigFile` setting to refer to your configuration file:

~~~ scala
webpackConfigFile in fastOptJS := Some(baseDirectory.value / "my.custom.webpack.config.js")
~~~

Or, if you want to use the same configuration file for both `fastOptJS` and `fullOptJS`:

~~~ scala
webpackConfigFile := Some(baseDirectory.value / "my.custom.webpack.config.js")
~~~

Then, you can write your configuration in file `my.custom.webpack.config.js`.
We recommend that you reuse the configuration file generated by scalajs-bundler
and extend it, rather than writing a configuration file from scratch.

You can do so as follows:

~~~ javascript
var webpack = require('webpack');

module.exports = require('./scalajs.webpack.config');

// And then modify `module.exports` to extend the configuration
~~~

The key part is the `require('./scalajs.webpack.config')`. It loads the configuration
file generated by scalajs-bundler so that you can tweak it. It works because your configuration
file will be copied into the internal target directory, where the scalajs-bundler generates
its configuration file, and where all the npm dependencies have been downloaded (so you can
also `require` these dependencies).

You can find a working example of custom configuration file
[here](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/static/prod.webpack.config.js).

## How to use npm modules from Scala code? {#facade}

Once you have [added npm dependencies](getting-started.md) to the packages you are interested
in, you have to *import* them from your code to effectively use them.

The recommended way to do that is to:

1. Write a [Scala.js](https://www.scala-js.org/doc/interoperability/facade-types.html)
  facade annotated with
  [`@JSImport`](https://www.scala-js.org/doc/interoperability/facade-types.html#a-nameimporta-imports-from-other-javascript-modules) ;
2. Refer to this facade from your code.

Let’s illustrate this with an example. Say that you want to write a facade for the following
npm module:

~~~ javascript tab="foo.js (CommonJS)"
exports.bar = function (i) { return i + 1 };
~~~

~~~ javascript tab="foo.js (ES6)"
export const bar = i => i + 1;
~~~

The corresponding Scala.js facade looks like the following:

~~~ scala
import scala.scalajs.js
import import scala.scalajs.js.annotation.JSImport

@JSImport("foo", JSImport.Namespace)
@js.native
object foo extends js.Object {
  def bar(i: Int): Int = js.native
}
~~~

There are several points worth highlighting:

- The first parameter of the `@JSImport` annotation is the npm module path. This is
  the value you would pass to the
  [Nodejs `require`](https://nodejs.org/docs/latest/api/modules.html#modules_all_together)
  function ;
- The second parameter of `@JSImport` is the name of the imported member, or like in our
  case, `JSImport.Namespace`, to import the whole module instead of just one particular
  member ;
- The facade is concrete. It can either be a Scala `object` or a `class` ;
- The facade has a
  [“JS native” type](https://www.scala-js.org/doc/interoperability/facade-types.html).

> {.note}
> Other styles of facades (importing a member in particular, importing functions and classes,
> importing local JavaScript files, etc.) can be found in
> [these tests](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/facade-examples).

Finally, in your Scala code, just refer to the `foo` object:

~~~ scala
object Main extends JSApp {
  def main(): Unit = {
    println(foo.bar(42))
  }
}
~~~

## How to publish a facade for an npm module? {#publish}

Create a project for the facade and enable the `ScalaJSBundlerPlugin` as described
[here](getting-started.md).

Implement the facade as explained in the [above section](cookbook.md#facade).

Publish the Scala.js project [as usual](http://www.scala-sbt.org/1.0/docs/Publishing.html).

Finally, to use the facade from another Scala.js project, this one needs both to add a
dependency on the facade and to enable the `ScalaJSBundlerPlugin` plugin.

> {.warning}
> Projects that **use** the facade also have to enable the `ScalaJSBundlerPlugin` plugin,
> otherwise the dependencies of the facade will not be resolved.

## How to use an existing facade assuming the JS library to be exposed to the global namespace? {#global-namespace}

Webpack is able to expose modules to the global namespace by using a custom loader:
[expose-loader](https://github.com/webpack/expose-loader). Thus, you can write a custom webpack configuration
file that uses this loader to expose the required modules to the global namespace. Typically, this file
will look like this:

~~~ javascript src=../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace/webpack.config.js
~~~

Also, tweak your `build.sbt` to add the corresponding NPM dependencies and to use the
custom webpack configuration file: 

~~~ scala src=../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace/build.sbt#relevant-settings
~~~

You can find a fully working example
[here](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace).