# Cookbook

![](toctree:local=true,mergeFirst=true)

## How to use a custom webpack configuration file? {#custom-config}

First, configure the `webpackConfigFile` setting to refer to your configuration file:

~~~ scala
webpackConfigFile in fastOptJS := Some(baseDirectory.value / "my.custom.webpack.config.js")
~~~

Or, if you want to use the same configuration file for both `fastOptJS` and `fullOptJS`:

~~~ scala
webpackConfigFile := Some(baseDirectory.value / "my.custom.webpack.config.js")
~~~

Then, you can write your configuration in file `my.custom.webpack.config.js`.
We recommend that you reuse the configuration file generated by scalajs-bundler
and extend it, rather than writing a configuration file from scratch.

You can do so as follows (in file `my.custom.webpack.config.js``):

~~~ javascript
var webpack = require('webpack');

module.exports = require('./scalajs.webpack.config');

// And then modify `module.exports` to extend the configuration
~~~

The key part is the `require('./scalajs.webpack.config')`. It loads the configuration
file generated by scalajs-bundler so that you can tweak it. It works because your configuration
file will be copied into the internal target directory, where the scalajs-bundler generates
its configuration file, and where all the npm dependencies have been downloaded (so you can
also `require` these dependencies).

By default `webpack` task only actually launches webpack if it detects changes in
settings or in the custom webpack config file. Depending on your usage scenario, you might
want to monitor some other files as well (for example, if your webpack config references
some additional resources). This can be achieved by using `webpackMonitoredDirectories`
setting:

~~~ scala
webpackMonitoredDirectories += baseDirectory.value / "my-scss"
includeFilter in webpackMonitoredFiles := "*.scss"
~~~

More fine-grained control over the list of monitored files is possible by overriding the
`webpackMonitoredFiles` task.

You can find a working example of custom configuration file
[here](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/static/prod.webpack.config.js).

It is also possible to configure a webpack config file to be used in reload workflow and when running the tests.
This configuration may not contain `entry` and `output` configuration but can be used to configure loaders etc.

These configuration files are configured using `webpackConfigFile in reloadTask` or `webpackConfigFile in Test`.
For example:

~~~ scala
webpackConfigFile in webpackReload := Some(baseDirectory.value / "common.webpack.config.js")

webpackConfigFile in Test := Some(baseDirectory.value / "common.webpack.config.js")
~~~

## Sharing webpack configuration among configuration files {#shared-config}

In addition to the configured webpack config file, all .js files in the project base directory
(as configured using the `webpackResources` setting) are copied to the target directory so they can be imported
from the various configuration files.

Here are the steps to share the loader configuration among your prod and dev config files. This
uses webpack-merge for convenience. The same result could be accomplished using plain js only.

1. Put configuration in a common.webpack.config.js file:

~~~ javascript
module.exports = {
  module: {
    loaders: [
        ...
    ],
    rules: [
        ...
    ]
  }
}
~~~

2. Add webpack-merge to your `npmDevDependencies`:

~~~
npmDevDependencies in Compile += "webpack-merge" -> "4.1.0"
~~~

3. Merge in the common configuration in your dev.webpack.js file:

~~~ javascript
var merge = require("webpack-merge")
var commonConfig = require("./common.webpack.config.js")

module.exports = merge(commonConfig, {
    ...
})
~~~

You can find a working example of a project using a shared configuration file
[here](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/sharedconfig).


## How to use npm modules from Scala code? {#facade}

Once you have [added npm dependencies](getting-started.md) to the packages you are interested
in, you have to *import* them from your code to effectively use them.

The recommended way to do that is to:

1. Write a [Scala.js](https://www.scala-js.org/doc/interoperability/facade-types.html)
  facade annotated with
  [`@JSImport`](https://www.scala-js.org/doc/interoperability/facade-types.html#a-nameimporta-imports-from-other-javascript-modules) ;
2. Refer to this facade from your code.

Let’s illustrate this with an example. Say that you want to write a facade for the following
npm module:

~~~ javascript tab="foo.js (CommonJS)"
exports.bar = function (i) { return i + 1 };
~~~

~~~ javascript tab="foo.js (ES6)"
export const bar = i => i + 1;
~~~

The corresponding Scala.js facade looks like the following:

~~~ scala
import scala.scalajs.js
import scala.scalajs.js.annotation.JSImport

@JSImport("foo", JSImport.Namespace)
@js.native
object foo extends js.Object {
  def bar(i: Int): Int = js.native
}
~~~

There are several points worth highlighting:

- The first parameter of the `@JSImport` annotation is the npm module path. This is
  the value you would pass to the
  [Nodejs `require`](https://nodejs.org/docs/latest/api/modules.html#modules_all_together)
  function ;
- The second parameter of `@JSImport` is the name of the imported member, or like in our
  case, `JSImport.Namespace`, to import the whole module instead of just one particular
  member ;
- The facade is concrete. It can either be a Scala `object` or a `class` ;
- The facade has a
  [“JS native” type](https://www.scala-js.org/doc/interoperability/facade-types.html).

> {.note}
> Other styles of facades (importing a member in particular, importing functions and classes,
> importing local JavaScript files, etc.) can be found in
> [these tests](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/facade-examples).

Finally, in your Scala code, just refer to the `foo` object:

~~~ scala
object Main extends JSApp {
  def main(): Unit = {
    println(foo.bar(42))
  }
}
~~~

## How to publish a facade for an npm module? {#publish}

Create a project for the facade and enable the `ScalaJSBundlerPlugin` as described
[here](getting-started.md).

Implement the facade as explained in the [above section](cookbook.md#facade).

Publish the Scala.js project [as usual](http://www.scala-sbt.org/1.0/docs/Publishing.html).

Finally, to use the facade from another Scala.js project, this one needs both to add a
dependency on the facade and to enable the `ScalaJSBundlerPlugin` plugin.

> {.warning}
> Projects that **use** the facade also have to enable the `ScalaJSBundlerPlugin` plugin,
> otherwise the dependencies of the facade will not be resolved.

## How to use an existing facade assuming the JS library to be exposed to the global namespace? {#global-namespace}

Webpack is able to expose modules to the global namespace by using a custom loader:
[expose-loader](https://github.com/webpack/expose-loader). Thus, you can write a custom webpack configuration
file that uses this loader to expose the required modules to the global namespace. Typically, this file
will look like this:

~~~ javascript src=../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace/webpack.config.js
~~~

Also, tweak your `build.sbt` to add the corresponding NPM dependencies and to use the
custom webpack configuration file: 

~~~ scala src=../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace/build.sbt#relevant-settings
~~~

You can find a fully working example
[here](https://github.com/scalacenter/scalajs-bundler/blob/master/sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/global-namespace).

## How to bundle an application having several entry points? {#several-entry-points}

By default, `ScalaJSBundlerPlugin` creates a Scala.js launcher that runs the application’s main class, and
uses this launcher as a webpack entry. This works fine as long as your project is an application with a
main class, but it will not work if you want to produce a single bundle exposing several entry points.

In such a case, you will have to override the `scalaJSLauncher` key to refer to the output of Scala.js
(instead of referring to the aforementioned generated launcher), and to use a custom webpack config file
telling to expose the bundle as a library.

`build.sbt`:

~~~ scala src="../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/library/build.sbt#relevant-settings"
~~~

`webpack.config.js`:

~~~ javascript tab="webpack.config.js" src="../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/library/webpack.config.js"
~~~

Then, assuming that you defined the following library:

~~~ scala src="../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/library/src/main/scala/example/Library.scala#library-definition"
~~~

You can call its methods as follows from your JavaScript code:

~~~ scala src="../../../sbt-scalajs-bundler/src/sbt-test/sbt-scalajs-bundler/library/index.html#library-usage"
~~~

## How to improve the performance of the bundling process? {#performance}

You can enable the [reload workflow](reference.md#reload-workflow) and disable source maps:

~~~ scala
enableReloadWorkflow := true
emitSourceMaps := false
~~~

## How to rebuild and reload your page on code changes? {#webpack-dev-server}

`scalajs-bundler` includes a simple wrapper over webpack-dev-server to simplify your
workflow. It is exposed as two stage-level tasks (`startWebpackDevServer` and
`stopWebpackDevServer`).
The standard work session looks like this:

1. Spawn background server process:
    ~~~
    > fastOptJS::startWebpackDevServer
    ~~~
    By default the server is started on port `8080`. Use `webpackDevServerPort` setting to change this.
2. Instruct SBT to rebuild on source changes:
    ~~~
    > ~fastOptJS
    ~~~
3. Now each time you change a source file, scala-js recompiles it, and webpack-dev-server
    switches to the updated version.
4. Shut down the background process:
    ~~~
    > fastOptJS::stopWebpackDevServer
    ~~~

Additional arguments can be passed to webpack-dev-server via `webpackDevServerExtraArgs`
setting. For example, you can add the following to your `build.sbt` to make your page
reload on every change:
~~~
webpackDevServerExtraArgs := Seq("--inline")
~~~
